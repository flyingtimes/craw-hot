# Session: 2026-02-28 11:48:00 UTC

- **Session Key**: agent:main:main
- **Session ID**: n/a
- **Source**: craw-hot 技能进程锁优化

## 问题

用户报告：`users.txt` 列表中的用户会被循环抓取很多次。

**问题分析：**

从日志中可以看到，程序被多次启动：
```
11:21:58  Progress: 1/19, Starting crawl for @vista8
11:29:20  Progress: 1/19, Starting crawl for @vista8  ← 重复启动
11:33:27  Progress: 1/19, Starting crawl for @vista8  ← 重复启动
11:40:02  Progress: 1/19, Starting crawl for @vista8  ← 重复启动
```

**根本原因：**
- 在测试过程中，多次启动了 `python3 craw_hot.py crawl` 命令
- 使用了 `background=true` 参数，导致多个进程在后台同时运行
- 每个实例都从头开始抓取，导致用户被重复抓取多次

## 解决方案

**craw-hot 技能 v2.4 - 进程锁机制**

### 核心改进

1. **进程锁类**：`ProcessLock` 类，使用文件锁机制
2. **自动检测**：启动时检查是否已有实例在运行
3. **友好提示**：检测到已有实例时显示清晰的错误信息
4. **自动释放**：程序退出时自动清理锁文件

### 代码实现

#### 1. 导入必要的模块

```python
import fcntl
import sys
```

#### 2. 新增 `ProcessLock` 类

```python
class ProcessLock:
    """进程锁，防止多个实例同时运行"""

    def __init__(self, lock_file: Path):
        self.lock_file = lock_file
        self.lock_fd = None

    def acquire(self) -> bool:
        """尝试获取锁"""
        try:
            self.lock_fd = open(self.lock_file, 'w')
            fcntl.flock(self.lock_fd.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_fd.write(str(os.getpid()))
            self.lock_fd.flush()
            return True
        except (IOError, BlockingIOError):
            return False

    def release(self):
        """释放锁"""
        if self.lock_fd:
            fcntl.flock(self.lock_fd.fileno(), fcntl.LOCK_UN)
            self.lock_fd.close()
            self.lock_fd = None

        if self.lock_file.exists():
            try:
                self.lock_file.unlink()
            except:
                pass

    def __enter__(self):
        return self.acquire()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.release()
```

#### 3. 在 `CrawlHot.__init__` 中获取锁

```python
def __init__(self):
    # 进程锁
    self.lock_file = SKILL_DIR / ".craw_hot.lock"
    self.process_lock = ProcessLock(self.lock_file)

    # 检查是否已有其他实例在运行
    if not self.process_lock.acquire():
        print(f"❌ Error: Another craw-hot instance is already running!")
        print(f"   Lock file: {self.lock_file}")
        print(f"   If you believe this is an error, delete the lock file and try again.")
        print(f"   Command: rm {self.lock_file}")
        sys.exit(1)

    # ... 其他初始化代码 ...
```

#### 4. 在 `CrawlHot.__del__` 中释放锁

```python
def __del__(self):
    """析构函数，确保释放进程锁"""
    if hasattr(self, 'process_lock') and self.process_lock:
        self.process_lock.release()
```

#### 5. 在 `main()` 中使用 try-finally 确保释放锁

```python
def main():
    """主函数 - 用于测试"""
    crawler = None

    try:
        crawler = CrawlHot()
        # ... 所有命令逻辑 ...
    finally:
        # 确保释放进程锁
        if crawler:
            crawler.process_lock.release()
```

### 测试结果

**测试命令：**
```bash
python3 craw_hot.py crawl vista8 & PID=$!
sleep 5
python3 craw_hot.py list
kill $PID
```

**预期输出：**
```
❌ Error: Another craw-hot instance is already running!
   Lock file: /path/to/.craw_hot.lock
   If you believe this is an error, delete the lock file and try again.
   Command: rm /path/to/.craw_hot.lock
```

## 优势

✅ **防止重复运行**：确保同一时间只有一个实例在运行
✅ **友好提示**：检测到已有实例时显示清晰的错误信息
✅ **自动清理**：程序正常退出时自动删除锁文件
✅ **容错设计**：即使异常退出，也会尝试清理锁文件

## 文件锁机制

**锁文件位置：** `/Users/clark/clawd/skills/craw-hot/.craw_hot.lock`

**锁机制：** 使用 `fcntl.flock()` 系统调用，确保进程级互斥

**特点：**
- 非阻塞获取（`LOCK_NB`）
- 跨平台支持（macOS, Linux）
- 进程结束时自动释放（通过文件描述符）

## 当前状态

进程锁功能已测试验证，正常工作中。
